{% extends "layout.html" %}

{% block title %}Torus Field Visualization{% endblock %}

{% block additional_styles %}
.info-panel {
    background: rgba(17, 24, 39, 0.8);
    border-radius: 8px;
    border: 1px solid rgba(79, 70, 229, 0.2);
}
.intention-display {
    background: linear-gradient(135deg, rgba(79, 70, 229, 0.1) 0%, rgba(147, 51, 234, 0.1) 100%);
    border-radius: 8px;
    border: 1px solid rgba(124, 58, 237, 0.3);
}
{% endblock %}

{% block content %}
<div class="mb-6">
    <h2 class="text-3xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-indigo-500">
        Torus Field Visualization
    </h2>
    <p class="text-gray-300">
        The torus is a fundamental pattern in sacred geometry that represents the flow of energy throughout the universe.
        A three-dimensional torus resembles a donut shape and symbolizes the continuous flow and recycling of energy.
    </p>
</div>

<div class="flex flex-col lg:flex-row gap-6">
    <div class="lg:w-2/3">
        <div class="visualization-container bg-black">
            <canvas id="torusCanvas" class="visualization-canvas"></canvas>
        </div>
    </div>
    
    <div class="lg:w-1/3">
        <div class="info-panel p-4 mb-4">
            <h3 class="text-xl font-bold mb-2 text-indigo-400">Field Properties</h3>
            
            <div class="mb-3">
                <label class="block text-sm font-medium text-gray-400 mb-1">Intention</label>
                <div class="intention-display p-3 text-white">
                    {{ intention|default:"Perfect health and vitality" }}
                </div>
            </div>
            
            <div class="mb-3">
                <label class="block text-sm font-medium text-gray-400 mb-1">Frequency</label>
                <div class="flex items-center">
                    <span class="text-white font-mono">{{ frequency|default:"7.83" }} Hz</span>
                    <span class="ml-2 text-xs text-indigo-400">(Schumann Resonance)</span>
                </div>
            </div>
            
            <div class="grid grid-cols-2 gap-2 mt-4">
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Inner Flow</label>
                    <span class="text-white">{{ inner_flow|default:"Clockwise" }}</span>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Outer Flow</label>
                    <span class="text-white">{{ outer_flow|default:"Counter-clockwise" }}</span>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Phase Angle</label>
                    <span class="text-white">{{ phase_angle|default:"45" }}Â°</span>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Coherence</label>
                    <span class="text-white">{{ coherence|default:"High" }}</span>
                </div>
            </div>
        </div>
        
        <div class="p-4 bg-gray-800 rounded-lg">
            <h3 class="text-xl font-bold mb-2 text-blue-400">Effects & Benefits</h3>
            <ul class="list-disc list-inside text-gray-300 space-y-1">
                <li>Balances energy centers and meridians</li>
                <li>Creates a protective energetic field</li>
                <li>Facilitates coherent intention manifestation</li>
                <li>Harmonizes with Earth's natural frequencies</li>
                <li>Supports meditation and mindfulness practices</li>
            </ul>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Get the canvas element
        const canvas = document.getElementById('torusCanvas');
        
        // Initialize the renderer
        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: true
        });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.setClearColor(0x000000, 1);
        
        // Create a scene
        const scene = new THREE.Scene();
        
        // Setup camera
        const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
        camera.position.z = 5;
        
        // Add orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Create torus geometry
        const torusGeometry = new THREE.TorusGeometry(2, 0.5, 32, 100);
        
        // Create pulsating material
        const torusMaterial = new THREE.MeshPhongMaterial({
            color: 0x4F46E5,
            emissive: 0x2563EB,
            emissiveIntensity: 0.5,
            shininess: 90,
            transparent: true,
            opacity: 0.9,
        });
        
        // Create the torus mesh
        const torus = new THREE.Mesh(torusGeometry, torusMaterial);
        scene.add(torus);
        
        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0x333333);
        scene.add(ambientLight);
        
        // Add directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 3, 5);
        scene.add(directionalLight);
        
        // Add particle system for energy flow
        const particleCount = 1000;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const particleSizes = new Float32Array(particleCount);
        
        // Position particles along the torus path
        for (let i = 0; i < particleCount; i++) {
            const t = i / particleCount;
            const theta = t * Math.PI * 2;
            const phi = t * Math.PI * 2;
            
            const R = 2; // Major radius
            const r = 0.5; // Minor radius
            
            const x = (R + r * Math.cos(phi)) * Math.cos(theta);
            const y = (R + r * Math.cos(phi)) * Math.sin(theta);
            const z = r * Math.sin(phi);
            
            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;
            
            particleSizes[i] = Math.random() * 0.05 + 0.03;
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
        
        // Create particle material
        const particleMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                color: { value: new THREE.Color(0x8B5CF6) },
            },
            vertexShader: `
                attribute float size;
                uniform float time;
                varying vec3 vColor;
                
                void main() {
                    vec3 pos = position;
                    
                    // Add subtle motion to particles
                    float phaseOffset = position.x + position.y + position.z;
                    float phase = time * 0.5 + phaseOffset;
                    
                    // Move particles along the torus
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = size * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                    
                    // Color variation
                    vColor = vec3(0.54, 0.36, 0.96);  // Purple base
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                
                void main() {
                    // Draw circular particles
                    vec2 center = gl_PointCoord - vec2(0.5);
                    float dist = length(center);
                    float alpha = smoothstep(0.5, 0.4, dist);
                    
                    gl_FragColor = vec4(vColor, alpha);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        });
        
        // Create the particle system
        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        
        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Rotate the torus
            torus.rotation.x += 0.03 * delta;
            torus.rotation.y += 0.02 * delta;
            
            // Pulse the torus
            const freq = {% if frequency %}{{ frequency }}{% else %}7.83{% endif %};
            const pulseScale = 1 + Math.sin(time * freq * 0.2) * 0.03;
            torus.scale.set(pulseScale, pulseScale, pulseScale);
            
            // Update particle system
            particleMaterial.uniforms.time.value = time;
            
            // Update controls
            controls.update();
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            renderer.setSize(width, height);
        });
        
        // Start animation
        animate();
    });
</script>
{% endblock %}